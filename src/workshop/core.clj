(ns workshop.core)
;; This is a tutorial that covers the basics of making sounds with Overtone.
;;
;; It is assumed that you understand basic Clojure syntax.
;;
;; We try to use only a very small set of available features of Overtone to simplify the explanation


;; Load Overtone first
(use 'overtone.live)

;; sine wave
;; ---------

(comment (image images/sin.png))
;; Play sine wave at 440Hz for 2 sec.
;; Note that higher the frequency, higher the pitch.
(demo 2 (sin-osc 440))

;; We can manipulate the amplitude of the generated sound with multiplication.
;; `sin-osc` generates sine waves with a value range of -1 to 1.
;; If we decrease the amplitude, the volume of sound also decreases.
(demo (* 1/2 (sin-osc 440)))

;; CAVEAT:
;; Waves arithmetic is only available within the `demo` macro defined by Overtone.
;; For example, if you try to evaluate the expression below outside of the `demo` macro:
;;
;;   (* 1/2 (sin-osc 440))
;;
;; You will get some error message like this:
;;
;; Unhandled java.lang.ClassCastException
;;    overtone.sc.machinery.ugen.sc_ugen.SCUGen cannot be cast to java.lang.Number

(comment (image images/multiply_sin.png))
;; The code below demonstrates how to change the amplitude over time.
;;
;; If the change of volume happens too rapidly, it would sound more like changing the timbre than
;; changing the volume.
;;
;; Both the expression structure and the parameters used in the following code sample below are
;; quite important: you should try to remember both of them :D
(demo 4 (* (sin-osc 0.4) (sin-osc 440)))

;; The code below demonstrates changing the frequency over time
;; You should be able to feel the sound vibrating.
;;
;; You can increase the degree of vibration, as well as make it vibrates more rapidly by tweaking
;; the parameters.
(demo 2 (sin-osc (+ 440 (* 8 (sin-osc 1)))))

;; you can use local variable when convenient
(demo 2 (let [freq (+ 440 (* 220 (sin-osc 0.2)))]
          (sin-osc freq)))

;; the code below demonstrates the sum of several sine waves
(demo 2 (let [freq 440]
          (->>                          ; using the threading macro
           (range 1 8)                  ; make integers from 1 to 7
           (map #(* freq %))            ; multiple each integer generated the line above
                                        ; with the fundamental frequency, i.e. making harmonic frequencies
           (map sin-osc)                ; map frequencies with sin-osc
           (apply +))))                 ; sum up all waves generated with `sin-osc`

;; --- For non-Clojurians ---
;; -> or ->> are used to change the order.
;;
;; The code above is same as below:
;;
;; (demo 2 (let [freq 440]
;;           (apply +
;;                  (map sin-osc
;;                       (map (fn [x] (* freq x))
;;                            (range 1 8))))))
;; --------------------------------------------

;; harmonic frequencies are an integral part of sounds generated by instruments, like those sounds
;; obtained by plucking the string or blowing the pipe
;;
;; You can read the explanation in detail from:
;; https://www.soundonsound.com/techniques/synthesizing-wind-instruments


;; clipping
;; --------

;; Clip signal. The output will be:
;;   1 if it's greater than  1
;;  -1 if it's less than    -1
(demo 2 (->                   ; be careful that here is a '->' not a '->>'
         (* 2 (sin-osc 440))  ; this expression is valued from -2 to 2
         (clip:ar -1 1)))     ; clip over 1 or under -1

;; Define a macro to prevent generating dangerously loud sounds
(defmacro safe-demo [demo-time body]
  `(demo ~demo-time
         (clip:ar ~body -1 1)))

;; Now you should use `safe-demo`
(safe-demo 2 (* 2 (sin-osc 440)))

;; envelope
;; --------

(comment (image images/env_lin.png))
;; Envelope is a line which are concatenated with several segments of line
;;
;; For example, (envelope [0 1 0] [0.05 0.5]) expresses such an envelope:
;;   firstly increase (e.g. the volume) from 0 to 1 in 0.05 sec
;;   then    decrease (e.g. the volume) from 1 to 0 in 0.5 sec,
;; where `env-gen` is used to turn parameters describing an envelope into a wave.


;; Multiply by envelope to shape the volume
(safe-demo 2 (let [freq 880
                   amp (env-gen (envelope [0 1 0] [0.05 0.5]))]
               (* amp (sin-osc freq))))

;; Let's consider what happens when you hit something:
;;   the collision of the hit causes vibration, that is, sound,
;;   whose volume might be quite loud at the beginning,
;;   but soon vanishes gradually.

;; Shorter the rising duration, harder the sound.
;; Shorter the descending duration, less the sound echos.

(comment (image images/env_quad.png))
;; We can use the third argument to `envelope` to specify the shape of segments constituting the
;; envelope:
;;   - 0 means linear,
;;   - a positive number means concave upward,
;;   - a negative number means concave downward.
;;   - also greater the absolute value, more the segment curves.
(safe-demo 2 (let [freq 880
                   amp (env-gen (envelope [0 1 0] [0.01 0.5] [0 -4]))]
               (* amp (sin-osc freq))))

(comment (image images/env_sin.png))
;; You can use `:sine` to specify the shape.
;;
;; It takes a short while for a blowing sound to become stable.
;; A certain level of volume should be kept for as long as the blowing sound goes.
(safe-demo 2 (let [freq 880
                   amp (env-gen (envelope [0 1 1 0] [0.2 0.3 0.7] [:sine 0 -4]))]
               (* amp (sin-osc freq))))

;; You can also use an envelope to control frequencies.
;; And an envelope can have more than two segments.
(safe-demo 2 (let [freq (env-gen (envelope [440 880 440 3520] [0.1 0.5 3]))]
               (sin-osc freq)))

(comment (image images/env_step.png))
;; example for discontinuous frequency change
(safe-demo 2 (let [freq (env-gen (envelope [900 900 1300]
                                           [0.1 0.5]
                                           :step)) ; `:step` indicates an immediately jump to the final value
                   amp  (env-gen (envelope [0 1 0] [0 0.6]))]
               (* amp (sin-osc freq))))

(comment (image images/env_step_2.png))
;; another example
(safe-demo 2 (let [freq (env-gen (envelope [440.0 440.0 880.0] [0.1 0.4]))
                   amp  (env-gen (envelope [1 0] [0.5]))]
               (* amp (sin-osc freq))))

;; fire envelope many times
(safe-demo 4 (let [gate (impulse 1)     ; at a repentance rate of 1Hz
                   freq 880
                   ; the envelope will be fired every time when `gate` changes from 1 to 0.
                   amp (env-gen (envelope [0 1 0] [0.05 0.5]) gate)]
               (* amp (sin-osc freq))))


;; white-noise and filter
;; ---------

;; (white-noise) generate a wave with random values in the range of -1 to 1.
;; As result, it contains all frequencies
(safe-demo 2 (white-noise))

;; The code below demonstrates multiplying white-noise by an envelope.
;; This would result a sound like percussion instruments playing
(safe-demo 2 (let [amp (env-gen (envelope [0 1 0] [0.05 0.2] -4))]
               (* amp (white-noise))))

;; Filtering
(safe-demo 2 (lpf (white-noise) 1000))       ; low pass filter
(safe-demo 2 (hpf (white-noise) 1000))       ; high pass filter
(safe-demo 2 (bpf (white-noise) 1000 0.1))   ; band pass filter (we can narrow the band with a 3rd argument)

;; The code below demonstrates the resonant low pass filter.
;; In this code sample, the sound is made emphasized around 1000Hz.
;; Also note that smaller the 3rd argument, stronger the emphasis.
(safe-demo 2 (rlpf (white-noise) 1000 0.1))

;; The code below demonstrates changing both the amplitude and the frequency by envelopes.
;; Note that the first 0.025 seconds in this particular case makes a huge difference.
(safe-demo 2 (let [freq (env-gen (envelope [3000 800] [0.025]))
                   amp  (env-gen (envelope [0 1 0] [0 0.5]))]
               (* amp (rlpf (white-noise) freq))))


;; stereo
;; ---------

;; Stereo sound could be made by passing a sequence with legth 2 to `demo` (in our case, `safe-demo`),
;;   - the left channel is created by the first element of the seq
;;   - the right channel is created by the second element of the seq
(safe-demo 2 (map sin-osc [440 660]))

;; One can set the phase offset (whose value must be within 0 and 1) with the second argument to `impulse`
(safe-demo 2 (map #(* (sin-osc %1)
                      (env-gen (envelope [0 1 0] [0.05 0.5]) (impulse 1 %2)))
                  [440 660]
                  [0 1/2]))

;; another stereo example.
;; the sound is moving around
(safe-demo 4 (map #(* (sin-osc 440)
                      ; the second argument (whose value is usually between 0 and 2Ï€)
                      ; to sin-osc sets the phase offset
                      (sin-osc 1/6 %))
                  [0 (* 1/2 Math/PI)]))

;; `splay` spreads an array of channels across the stereo field
(safe-demo 8 (splay
              (map
               ; the first argument to this lambda sets the frequency
               ; and the second argument sets the phase
               #(* 4 (sin-osc %1)
                   (env-gen (envelope [0 1 0] [0.01 0.5] -4)
                            (impulse 1/2 %2)))

               (iterate #(* 1.5 %) 400) ; a sequence of frequencies
               (->> (range 0 1 1/10)    ; and a sequence of phases
                        (rotate 1)
                        reverse))))

;; exercise
;; ---------

;; try to create your own sounds that are:
;;   - more and more complicated
;;   - more and more noisy
;;   - closer and closer to real acoustics
;;   - and maybe like some strange instruments

;; some code examples to create complex sounds
(shuffle (range 100 1000 100))

(take 16 (interleave (iterate #(* 1.5 %) 400)
                    (iterate #(* 9/5 %) 300)))       ; don't forget `take`.

(->> (reductions * 1000 (cycle [5/4 7/3 11/10 3/5 4/7]))
     (take 20))

(safe-demo 1 (reduce (fn [acc x] (sin-osc (* x acc)))
                     (sin-osc 10)
                     (range 1000 5000 1000)))

;; advanced topics
;; ---------

(comment
  ;; if SuperCollider (SC) is running, you can connect to it instead of using (use 'overtone.live).
  ;; You need to execute `s.option.maxLogins = 2` before you launch SC server.
  ;; (Ctrl/CMD + Enter to execute in SC's IDE)
  ;;
  ;; You can see the resulted wave by executing `s.scope`,
  ;; or frequency by executing `s.freqscope`.
  (use 'overtone.core)
  (connect-external-server "localhost" 57110))


;; "multichannel expansion" is supported so that the two code blocks below result the same
(safe-demo 2 (splay
              (map *
                   (map sin-osc (range 500 1500 100))
                   (map #(env-gen (envelope [0 1 0] [0.05 0.5]) (impulse 1 %))
                        (range 0 1 0.1)))))

(safe-demo 2 (splay
              (* (sin-osc (range 500 1500 100))
                 (env-gen (envelope [0 1 0] [0.05 0.5]) (impulse 1 (range 0 1 0.1))))))

;; The `demo` macro releases resources after certain amount of time
;; (the first argument to the macro, in seconds).
;;
;; You can also manage the life time of sound manually.
;; In this example, resources will be released after 0.55 seconds.
(demo 2 (let [freq (env-gen (envelope [3000 440] [0.1]))
              amp  (env-gen (envelope [0 1 0] [0.05 0.5]) :action FREE)]
          (* amp (sin-osc freq))))

